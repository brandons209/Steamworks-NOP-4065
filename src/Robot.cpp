// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<DriveTrain> Robot::driveTrain;
std::shared_ptr<Launcher> Robot::launcher;
std::shared_ptr<Loader> Robot::loader;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

std::shared_ptr<IntakeAndWinch> Robot::intakeAndWinch;

SendableChooser<std::string> Robot::allianceColor;
SendableChooser<std::string> Robot::driverStation;
SendableChooser<std::string> Robot::autoChooser1;
SendableChooser<std::string> Robot::autoChooser2;

double Robot::xOffset, Robot::yOffset;
std::string Robot::allianceSide;

static void drawRectangles(){
	cs::CvSink cvSink = CameraServer::GetInstance()->GetVideo();
	cs::CvSource outputStream = CameraServer::GetInstance()->PutVideo("Gear Box", 640, 480);
	cv::Mat source;

	while(true){
		cvSink.GrabFrame(source);

		if(!source.empty()){
			cv::Point leftTop = cv::Point((640.0/2.0) - 10.0, 480.0/2.0);
			cv::Point rightBot = cv::Point((640.0/2.0) + 10.0, 479);

			cv::rectangle(source, leftTop, rightBot, cv::Scalar( 0, 255, 255 ), 4);

			outputStream.PutFrame(source);
		}else{
			std::cout << "no image" << std::endl;
		}
	}

}

void Robot::chooseAllianceNumber(){
	const double station3X = 102.97;
	const double station2X = 175.16;
	const double station1X = 205.97;
	yOffset = 25.5 - 6.36;
	if(driverStation.GetSelected() == "1"){
		xOffset = station1X;
	}else if(driverStation.GetSelected() == "2"){
		xOffset = station2X;
	}else{
		xOffset = station3X;
	}
}


void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    driveTrain.reset(new DriveTrain());
    launcher.reset(new Launcher());
    loader.reset(new Loader());
    intakeAndWinch.reset(new IntakeAndWinch());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	allianceSide = "";
	// instantiate the command used for the autonomous period



	allianceColor.AddDefault("Blue Alliance", "blue");
	allianceColor.AddObject("Red Alliance", "red");
	SmartDashboard::PutData("Choose Alliance Side", &allianceColor);
	allianceSide = allianceColor.GetSelected();

	driverStation.AddDefault("Station 1", "1");
	driverStation.AddObject("Station 2", "2");
	driverStation.AddObject("Station 3", "3");
	SmartDashboard::PutData("Choose Station Number", &driverStation);

	chooseAllianceNumber();

	autoChooser1.AddDefault("Drive Forward", "drive");
	autoChooser1.AddObject("Do Nothing", "nothing");
	autoChooser1.AddObject("Gear station 1", "g1");
	autoChooser1.AddObject("Gear station 2", "g2");
	autoChooser1.AddObject("Gear station 3", "g3");
	SmartDashboard::PutData("First Auto Mode", &autoChooser1);

	autoChooser2.AddDefault("Do Nothing", "nothing");
	autoChooser2.AddObject("Shoot station 1", "s1");
	autoChooser2.AddObject("Shoot station 2", "s2");
	autoChooser2.AddObject("Shoot station 3", "s3");
	SmartDashboard::PutData("Second Auto Mode", &autoChooser2);

	updatePosition.reset(new UpdatePosition());

	SmartDashboard::PutNumber("Drive to point x:", 0);
	SmartDashboard::PutNumber("Drive to point y:", 0);

	cs::UsbCamera cvcam;
	cvcam = CameraServer::GetInstance()->StartAutomaticCapture();
	cvcam.SetResolution(640,480);

	std::thread gearboxThread(drawRectangles);
	gearboxThread.detach();

	driveTrain.get()->ahrs.get()->ZeroYaw();

  }

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	updatePosition->Start();
}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit() {
	updatePosition->Start();
	allianceSide = allianceColor.GetSelected();
	chooseAllianceNumber();
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Start();
}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	chooseAllianceNumber();
	allianceSide = allianceColor.GetSelected();
	updatePosition->Start();
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();
}

void Robot::TeleopPeriodic() {
	/*Vision *vision = new Vision();
	vision->processVision();

	cv::Rect bb = cv::boundingRect(vision->visionOutput.at(0));

	if(vision->visionOutput.empty()){

	}else{//x and y are the point of the top left corner
		std::cout << "x: " << bb.x << " y: " << bb.y << " area: " << bb.area() << " width: " << bb.width << " height: " << bb.height << std::endl;

		//double distance1 = (RobotMap::testTargetWidth * (10/12) * 640) / (2*bb.width*(tan(RobotMap::cameraHorizontalViewAngle) * 180/3.1415) );
		double distance1 = (RobotMap::testTargetWidth * RobotMap::cameraFocalLength) / bb.width;
		//need some fix here, sometimes off by a few inches
		std::cout << "distance " << distance1 << std::endl;
		SmartDashboard::PutNumber("Distance", distance1);
	}*/


	Scheduler::GetInstance()->Run();
}

void Robot::TestPeriodic() {
	lw->Run();
}

START_ROBOT_CLASS(Robot);

