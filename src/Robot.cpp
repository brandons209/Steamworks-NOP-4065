// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<DriveTrain> Robot::driveTrain;
std::shared_ptr<Launcher> Robot::launcher;
std::shared_ptr<Loader> Robot::loader;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

std::shared_ptr<IntakeAndWinch> Robot::intakeAndWinch;

static void drawRectangles(){
	cs::CvSink cvSink = CameraServer::GetInstance()->GetVideo();
	cs::CvSource outputStream = CameraServer::GetInstance()->PutVideo("Gear Box", 640, 480);
	cv::Mat source;
	cv::Mat output;
	Vision v;

	while(true){
		cvSink.GrabFrame(source);
		cv::Point center = cv::Point(640.0/2.0, 480.0/2.0);
		cv::Point bottom = cv::Point(640.0/2.0, 479.0);

		output = v.connectLine(source, center, bottom);

		outputStream.PutFrame(output);

	}

}


void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    driveTrain.reset(new DriveTrain());
    launcher.reset(new Launcher());
    loader.reset(new Loader());
    intakeAndWinch.reset(new IntakeAndWinch());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	autonomousCommand.reset(new DriveToPosition());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	SmartDashboard::PutNumber("Desired Angle", 0);
	SmartDashboard::PutNumber("X distance from center of boiler", 0);
	SmartDashboard::PutNumber("Y distance from center of boiler", 0);

	SmartDashboard::PutString("alliance color for boiler side:(red or blue)", "red");

	updatePosition.reset(new UpdatePosition());
	updatePosition->Start();

	SmartDashboard::PutNumber("Drive to point x:", 0);
	SmartDashboard::PutNumber("Drive to point y:", 0);

	cs::UsbCamera cvcam;
	cvcam = CameraServer::GetInstance()->StartAutomaticCapture();
	cvcam.SetResolution(640,480);//generate grip code includeing wpi pipelane. then use threading

	std::thread gearboxThread(drawRectangles);
	gearboxThread.detach();

  }

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){

}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit() {
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Start();
}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();
}

void Robot::TeleopPeriodic() {
	/*Vision *vision = new Vision();
	vision->processVision();

	cv::Rect bb = cv::boundingRect(vision->visionOutput.at(0));

	if(vision->visionOutput.empty()){

	}else{//x and y are the point of the top left corner
		std::cout << "x: " << bb.x << " y: " << bb.y << " area: " << bb.area() << " width: " << bb.width << " height: " << bb.height << std::endl;

		//double distance1 = (RobotMap::testTargetWidth * (10/12) * 640) / (2*bb.width*(tan(RobotMap::cameraHorizontalViewAngle) * 180/3.1415) );
		double distance1 = (RobotMap::testTargetWidth * RobotMap::cameraFocalLength) / bb.width;
		//need some fix here, sometimes off by a few inches
		std::cout << "distance " << distance1 << std::endl;
		SmartDashboard::PutNumber("Distance", distance1);
	}*/


	Scheduler::GetInstance()->Run();
}

void Robot::TestPeriodic() {
	lw->Run();
}

START_ROBOT_CLASS(Robot);

